# Render
Когда мы говорим о рендеринге в React, мы имеем в виду процесс, посредством которого React-компоненты преобразуются в HTML-элементы, отображаемые в браузере. Этот процесс включает несколько важных этапов и концепций, которые помогают React быть быстрым и эффективным.

# Основные концепции

## Виртуальный DOM (Virtual DOM)

Виртуальный DOM — это облегченная копия реального DOM. React использует виртуальный DOM для более быстрой работы. Когда происходят изменения в компонентах, React сначала обновляет виртуальный DOM, а потом уже реальный DOM, что позволяет значительно уменьшить количество операций с реальным DOM, которые являются затратными по времени.

## Реактивное обновление

Реактивное обновление означает, что когда изменяются данные (состояние или свойства) компонента, React автоматически перерисовывает компонент. Этот процесс автоматический и не требует явного вмешательства со стороны разработчика.

### Жизненный цикл компонента
* Каждый React-компонент проходит через несколько стадий жизненного цикла:

* Монтирование (Mounting): Когда компонент впервые добавляется в DOM.
* Обновление (Updating): Когда компонент обновляется из-за изменения состояния или свойств.
* Размонтирование (Unmounting): Когда компонент удаляется из DOM.
* Обработка ошибок (Error Handling): Когда в процессе работы компонента возникают ошибки.


# Шаги рендеринга
1. Инициализация

Когда компонент создается (чаще всего в конструкторе для классовых компонентов или при первом вызове для функциональных компонентов), происходит инициализация его состояния и свойств.

```js
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  render() {
    return <div>{this.state.count}</div>;
  }
}
```

## 2. Вызов метода render
После инициализации вызывается метод render. Он возвращает описание интерфейса в виде элементов React. Это описание используется для создания или обновления виртуального DOM.

```js

render() {
  return <div>{this.state.count}</div>;
}
```


3.  Обновление виртуального DOM
React создает или обновляет виртуальный DOM на основе результата метода render.

4. Сравнение (Reconciliation)

React сравнивает новый виртуальный DOM с предыдущим состоянием виртуального DOM, чтобы определить, какие части интерфейса изменились.

5. Обновление реального DOM

После сравнения React обновляет реальный DOM только в тех местах, где произошли изменения. Это делает обновление более эффективным.

# Пример с изменением состояния
Рассмотрим пример с изменением состояния:

```js
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <h1>{this.state.count}</h1>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}
```


# Инициализация: Компонент Counter создается с начальным состоянием count: 0.
* Вызов render: Метод render возвращает элемент <div>, содержащий текущее значение count и кнопку.
* Обновление виртуального DOM: React обновляет виртуальный DOM, создавая элемент с текущим значением count.
* Сравнение: Виртуальный DOM сравнивается с предыдущей версией. Если есть изменения (например, после нажатия кнопки), React определяет, какие именно изменения произошли.
* Обновление реального DOM: После сравнения React обновляет реальный DOM, изменяя только те части, которые изменились (например, текст в теге <h1>).



# Оптимизация рендеринга

* shouldComponentUpdate: Метод класса, который позволяет контролировать, следует ли компоненту рендериться при изменении состояния или свойств.

```js
shouldComponentUpdate(nextProps, nextState) {
  return nextState.count !== this.state.count;
}
```

* React.memo: ХOC для функциональных компонентов, который предотвращает повторный рендеринг, если свойства не изменились.

* useMemo и useCallback: Хуки, которые позволяют мемоизировать значения и функции соответственно, чтобы предотвратить их переопределение при каждом рендере.

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

# Заключение
Рендеринг в React — это процесс преобразования компонентов в элементы DOM. Он включает создание виртуального DOM, сравнение с предыдущей версией и обновление реального DOM на основе изменений. Понимание этого процесса и использование инструментов оптимизации позволяет создавать более производительные приложения.


# Если у вас остались вопросы или что-то еще нужно уточнить, дайте знать!







# Сборщик мусора

* Сборщик мусора (garbage collector) — это механизм управления памятью, который автоматически освобождает память, занимаемую объектами, которые больше не используются программой. В контексте программирования и выполнения программ, это крайне важно для предотвращения утечек памяти и оптимизации использования доступной памяти.

1. Как работает сборщик мусора
Создание объектов: Когда программа создает объекты, они занимают память.

2. Определение неиспользуемых объектов: Сборщик мусора периодически проверяет, какие объекты больше не используются (т.е. на них нет ссылок в коде).

3. Освобождение памяти: Объекты, которые больше не нужны, удаляются, и память, которую они занимали, освобождается.



* Алгоритмы сборки мусора
` Существуют различные алгоритмы для реализации сборщика мусора, и каждый из них имеет свои особенности и области применения. Вот несколько распространенных:
Reference Counting: Каждому объекту присваивается счетчик ссылок. Когда счетчик становится нулевым (т.е. на объект больше нет ссылок), память освобождается. Недостаток: не может обнаружить циклические ссылки.

Mark-and-Sweep:

 * Mark (Пометка): Сборщик мусора проходит по всем объектам, начиная с корневых объектов (например, глобальные переменные), и помечает все доступные объекты.
 * Sweep (Очистка): Все непомеченные объекты считаются неиспользуемыми и удаляются.
Copying Collector: Память делится на две области. Активные объекты копируются из одной области в другую, неактивные остаются и память под ними освобождается.

Generational Garbage Collection: Объекты делятся на поколения. Молодые объекты (новые) собираются чаще, чем старые объекты, так как большинство объектов "умирает" молодыми.
`

## Пример без утечек памяти
```js
 function createUser() {
  let user = {
    name: "John"
  };
  // user используется, затем выходит из области видимости
}

createUser(); // user больше не доступен, память будет освобождена
```

## Пример с утечкой памяти
```js
let userList = [];
function createUser() {
  let user = {
    name: "John"
  };
  userList.push(user); // user остается в памяти, т.к. на него есть ссылка в userList
}

createUser(); // каждый вызов createUser добавляет нового user в userList
```

